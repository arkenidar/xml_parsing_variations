<title>pack html</title>
<meta charset="utf-8">

<div id="pack_this" style="display: none"><div class="msg">HTML text ENCODER</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div><div class="msg">some text</div></div>

<b>statistics</b>
<div id="stats"></div>
<hr>

<b>packing results in this</b>
<div id="packed"></div>
<hr>

<b>packed from this HTML</b>
<div id="packed_from_this"></div>
<hr>

<div style="display:none" id="inject"></div>

<script>

function processDOM(nodes,dictionary){

dictOn=()=>typeof dictionary!='undefined'

function processNodes(nodes){
    var subNodes=[]
    for(processedNode of nodes){
        subNodes.push(processNode(processedNode))
    }
    return subNodes.join('')
}

function processNode(processedNode){
    
    function addToDictionary(name){
        if(!dictOn()) return
        if(name in dictionary)
            dictionary[name]+=name.length
        else
            dictionary[name]=name.length
    }

    switch(processedNode.nodeType){
        case processedNode.TEXT_NODE:
            return processedNode.textContent
            break
        case processedNode.ELEMENT_NODE:
            var produced=[]
            var tagName=processedNode.tagName.toLowerCase()
            addToDictionary(tagName)
            produced.push('{'+tagName)
            var attribute_section=[]
            for(attribute of processedNode.attributes){
                var nodeName=attribute.nodeName
                addToDictionary(nodeName)
                attribute_section.push(nodeName+'|'+attribute.nodeValue)
            }
            produced.push(...attribute_section)
            if(processedNode.childNodes){
                var sub=processNodes(processedNode.childNodes)
                if(sub!='')produced.push(sub)
            }
            return produced.join('|')+'}'
            break
    }
}

var text=processNodes(nodes)
return {text,dictionary}
}

// HTML => packed
function pack(node,dictionary){
    var packed=processDOM(node.childNodes,dictionary)
    if(typeof dictionary!='undefined'){
        packed.dictionary=dictSort(packed.dictionary)
        packed.dictionary=packed.dictionary.map(e=>e[0])
    }
    return packed
}

// packed => HTML
function unpack(string,codes){
    return parse(string,codes)
}

function $(id){
    return document.getElementById(id)
}

var packingResults=pack($('pack_this'),{})
$('packed').innerHTML=packingResults.text

var previousLenght= $('pack_this').innerHTML.length
var reduction=previousLenght-$('packed').innerHTML.length

$('stats').innerHTML='reduced of '+reduction+' of '+previousLenght+
' -- <b>'+reduction/(previousLenght/100)+'%</b>'
$('packed_from_this').innerText=$('pack_this').innerHTML

var equivalence=$('pack_this').innerHTML==unpack($('packed').innerHTML,(i)=>i)
$('stats').innerHTML+='<div>is packed equivalent to source? <b>'+equivalence+'</b>'

//////////////////////////////////////

function parse(str,codes){
    if(str=='') return '';
    var level=0;
    buffer='';
    for(var i=0;i<str.length;i++){
        if(level==0 && str[i]!='{' && str[i]!='}')
            buffer+=str[i];
        if(str[i]=='{'){
            if(level==0) open=i;
            level++;
        }
        if(str[i]=='}'){
            level--;
            if(level==0) {
                close=i;
                var text=str.substring(open, close+1);
                buffer+=parens(text,codes);
            }
        }
    }
    return buffer;
}

function parens(str,codes){
    var parts=str.substring(1);
    parts=parts.substring(0,parts.length-1);
    var buffer='';
    var array=[];
    for(var i=0; i<parts.length; i++)
    {
        if(parts[i]=='{'){
            array.push(buffer+parts.slice(i));
            buffer='';
            break;
        }
        if(parts[i]!='|'){
            buffer+=parts[i];
        }
        if(parts[i]=='|'){
            array.push(buffer);
            buffer='';
        }
        if(i==parts.length-1){
            array.push(buffer);
            buffer='';
        }
    }
    parts=array;
    var tagname=codes(parts[0]);
    parts=parts.slice(1);
    var content='';
    if((parts.length%2)==1){
        content=parts[parts.length-1];
        parts.splice(-1);
    }
    var attributes='';
    for(var i=0; i<parts.length; i+=2){
        if(parts[i+1]!='')
            attributes+=' '+codes(parts[i])+'="'+parts[i+1]+'"';
        else
            attributes+=' '+codes(parts[i]);
    }
    var to_return='<'+tagname+attributes+'>'+parse(content,codes)+'</'+tagname+'>';
    return to_return;
}

//////////////////////////////////////////////

function dictSort(dict){
    // create items array
    var items = Object.entries(dict)

    // sort the array based on the second element
    items.sort(function(first, second) {
        return second[1]-first[1]
    })

    return items
}

//////////////////////////////////////////////

$('inject').innerHTML='<div class="msg">some text</div>'
console.log(testPack1And2AndUnpack($('inject')))

function testPack1And2AndUnpack(node){
    // pack phase1
    var packed=pack(node,{})
    // pack phase2
    var parsedCodes=parseCodes(packed.text,code=>packed.dictionary.indexOf(code))
    // unpack from phase2
    var unpackedCodes=unpack(parsedCodes,i=>packed.dictionary[i])
    return {packed,parsedCodes,unpackedCodes}
}

//////////////////////////////////////////////

function parensCodes(str,codes){
    var parts=str.substring(1);
    parts=parts.substring(0,parts.length-1);
    var buffer='';
    var array=[];
    for(var i=0; i<parts.length; i++)
    {
        if(parts[i]=='{'){
            array.push(buffer+parts.slice(i));
            buffer='';
            break;
        }
        if(parts[i]!='|'){
            buffer+=parts[i];
        }
        if(parts[i]=='|'){
            array.push(buffer);
            buffer='';
        }
        if(i==parts.length-1){
            array.push(buffer);
            buffer='';
        }
    }
    parts=array;
    var tagname=codes(parts[0]);
    parts=parts.slice(1);
    var content='';
    if((parts.length%2)==1){
        content=parts[parts.length-1];
        parts.splice(-1);
    }
    var attributes='';
    for(var i=0; i<parts.length; i+=2){
        attributes+='|'+codes(parts[i])+'|'+parts[i+1];
    }
    var subpart=parseCodes(content,codes);
    if(subpart!='') subpart='|'+subpart;
    var to_return='{'+tagname+attributes+subpart+'}';
    return to_return;
}

function parseCodes(str,codes){
    if(str=='') return '';
    var level=0;
    buffer='';
    for(var i=0;i<str.length;i++){
        if(level==0 && str[i]!='{' && str[i]!='}')
            buffer+=str[i];
        if(str[i]=='{'){
            if(level==0) open=i;
            level++;
        }
        if(str[i]=='}'){
            level--;
            if(level==0) {
                close=i;
                var text=str.substring(open, close+1);
                buffer+=parensCodes(text,codes);
            }
        }
    }
    return buffer;
}

</script>
